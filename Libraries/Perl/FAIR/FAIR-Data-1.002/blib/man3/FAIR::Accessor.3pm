.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FAIR::Accessor 3pm"
.TH FAIR::Accessor 3pm "2016-10-20" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FAIR::Accessor \- all this does is assign the HTTP call to the correct routine
.SH "VERSION"
.IX Header "VERSION"
version 1.002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following code is a complete implementation of a 'Hello, World!' \s-1FAIR\s0 Accessor
.PP
.Vb 1
\& C<##!/usr/local/bin/perl \-w
\&
\& package MyFirstAccessor;  # this should be the same as your filename!
\& use FindBin;                # where was script installed?
\& use lib "$FindBin::Bin";      # use that dir for libs, too
\& use strict;
\& use warnings;
\& use JSON;
\& use FAIR::Accessor::Distribution;
\& use FAIR::Accessor::Container;
\& use FAIR::Accessor::MetaRecord;
\&
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Configuration and Daemon
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\& use base \*(AqFAIR::Accessor\*(Aq;
\&
\& my $config = {
\&   title => \*(AqExample FAIR Accessor\*(Aq,
\&   serviceTextualDescription => \*(AqBare\-bones FAIR Accessor\*(Aq,
\&   textualAccessibilityInfo => "The information from this server requries no authentication; HTTP GET is sufficient",  # this could also be a $URI describing the accessibiltiy
\&   mechanizedAccessibilityInfo => "",  # this must be a URI to an RDF document
\&   textualLicenseInfo => "CC0",  # this could also be a URI to the license info
\&   mechanizedLicenseInfo =>  "https://creativecommons.org/choose/zero/", # this must be a URI to an RDF document
\&   ETAG_Base => "SomeIdentifierOfMyAccessor", # this is a unique identificaiton string for the service (required by the LDP specification)
\&   localNamespaces => {
\&        pfund => \*(Aqhttp://vocab.ox.ac.uk/projectfunding#term_\*(Aq,
\&        up => \*(Aqhttp://uniprot.org/ontology/core#\*(Aq, 
\&        },  # add a few new namespaces to the list of known namespaces....
\&   basePATH => \*(Aqcgi\-bin/Accessors/MyFirstAccessor\*(Aq, # REQUIRED regexp to match the PATH part of the URL, before the ID number
\&
\& };
\&            
\& my $service = UniProtAccessor\->new(%$config);
\&
\& # start daemon
\& $service\->handle_requests;
\&
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Accessor Implementation
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\- Container Resource \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\& sub Container {    REQUIRED SUBROUTINE NAME!!!!
\&
\&   my ($self, %ARGS) = @_;
\&   
\&   my $Container = FAIR::Accessor::Container\->new(NS => $self\->Configuration\->Namespaces);
\&    
\&   my $BASE_URL = "http://" . $ENV{\*(AqSERVER_NAME\*(Aq} . $ENV{\*(AqREQUEST_URI\*(Aq};
\&
\&   my @recordIDs = (1,2,3,4,5,6,7);
\&   my @recordURLs;
\&   foreach my $ID (@recordIDs) {
\&      push @recordURLs, "$BASE_URL/$ID";   # need to make a URL for each of the meta\-records, based on the ID of the PHIBase record, push it onto a list
\&   }
\&  
\&   $Container\->addRecords(\e@recordURLs); # the listref of record ids
\&   $self\->fillContainerMetadata($Container);
\&
\&   return $Container;
\& }
\&
\& # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-MetaRecord Resource \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\& sub MetaRecord {   REQUIRED SUBROUTINE NAME
\&   my ($self, %ARGS) = @_;
\&
\&   my $ID = $ARGS{\*(AqID\*(Aq};
\&
\&   my $MetaRecord = FAIR::Accessor::MetaRecord\->new(ID => $ID,
\&                                                    NS => $self\->Configuration\->Namespaces);
\&   $self\->fillMetaRecordMetadata($MetaRecord);
\&   
\&   $MetaRecord\->addDistribution(availableformats => [\*(Aqtext/html\*(Aq],
\&                                downloadURL => "http://www.uniprot.org/uniprot/$ID.html");
\&   $MetaRecord\->addDistribution(availableformats => [\*(Aqapplication/rdf+xml\*(Aq],
\&                                downloadURL => "http://www.uniprot.org/uniprot/$ID.rdf");
\&
\&   
\&   my $encodedsubject = urlencode("http://identifiers.org/uniprot/$ID");
\&   my $encodedpredicate = urlencode("http://purl.uniprot.org/core/organism");
\&   my $TPF = "http://my.TPF.server.org/fragments?subject=$encodedsubject&predicate=$encodedpredicate";  
\&   $MetaRecord\->addDistribution(
\&         availableformats => ["application/x\-turtle", "application/rdf+xml", "text/html"],
\&         downloadURL => $TPF,
\&         source => "http://identifiers.org/uniprot/$ID",
\&         subjecttemplate =>  "http://identifiers.org/uniprot/{ID}",
\&         subjecttype => "http://purl.uniprot.org/core/organism",
\&         predicate => "http://purl.uniprot.org/core/organism",
\&         objecttemplate => "http://identifiers.org/taxon/{TAX}",
\&         objecttype => "http://edamontology.org/data_1179",      
\&   );
\&   
\&   return $MetaRecord;
\&
\& }
\&
\& sub fillContainerMetadata {
\&   my ($self, $Container) = @_;
\&   $Container\->addMetadata({
\&      \*(Aqdc:title\*(Aq => "Generic FAIR Accessor example",
\&      \*(Aqdcat:description\*(Aq => "For Example",
\&      \*(Aqdcat:identifier\*(Aq => "http://linkeddata.systems/cgi\-bin/Accessors/MyFirstAccessor",  # NOTE the filename and path!  set in the top\-level %config hash!
\&      \*(Aqdcat:keyword\*(Aq => ["Go", "FAIR"],
\&      \*(Aqdc:license\*(Aq => \*(Aqhttps://creativecommons.org/choose/zero\*(Aq,
\&      \*(Aqrdf:type\*(Aq => [\*(Aqprov:Collection\*(Aq, \*(Aqdctypes:Dataset\*(Aq],
\&   });
\& }
\&
\& sub fillMetaRecordMetadata {
\&  my ($self, $MetaRecord) = @_;
\&  my $ID = $MetaRecord\->ID;
\&  $MetaRecord\->addMetadata({
\&      \*(Aqfoaf:primaryTopic\*(Aq => "http://my.database.org/records/$ID",
\&      \*(Aqdc:title\*(Aq => "Record $ID",
\&      \*(Aqdcat:identifier\*(Aq => "http://my.database.org/records/$ID",
\&      \*(Aqdcat:keyword\*(Aq => ["Go", "FAIR"],
\&      \*(Aqdc:creator\*(Aq => \*(AqMe\*(Aq,
\&      \*(Aqdc:bibliographicCitation\*(Aq => "Joe Bloggs (2016). How to write a FAIR Accessor, Online Journal 4:3.",
\&      \*(Aqvoid:inDataset\*(Aq => \*(Aqhttp://linkeddata.systems/cgi\-bin/Accessors/UniProtAccessor/\*(Aq,
\&      \*(Aqdc:license\*(Aq => \*(Aqhttps://creativecommons.org/choose/zero\*(Aq,
\&        });
\& 
\& }
\&
\& sub urlencode {
\&    my $s = shift;
\&    $s =~ s/ /+/g;
\&    $s =~ s/([^A\-Za\-z0\-9\e+\-])/sprintf("%%%02X", ord($1))/seg;
\&    return $s;
\& }
.Ve
.PP
>
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1FAIR\s0 Accessors are inspired by the W3Cs Linked Data Platform \*(L"Containers\*(R".
.PP
\&\s-1FAIR\s0 Accessors follow a two-stage interaction, where the first stage
retrieves metadata about the repository \*(L"Container\*(R"), and (optionally)
a series of URLs representing 'MetaRecords' for every record in
that repository (or whatever slice of the repository is being served).
This is accomplished by the \fBContainer\fR subroutine.  These URLs
will generally point back at this same Accessor script (e.g. with the
record number appended to the \s-1URL:  \s0\fIhttp://this.host/thisscript/12345\fR).
.PP
The second stage involves retrieving metadata about individual recoreds.
The metadata is up to you, but optimally it would include the available
\&\s-1DCAT\s0 distributions and their file formats.  The second stage can be accomplished
by this same Accessor script, using the Distributions subroutine.
.PP
The two subroutine names \- \fBContainer\fR  and  \fBMetaRecord\fR \- are not flexible, as they are
called by-name, by the Accessor libraries.
.PP
You \fB\s-1MUST\s0\fR create the \fBContainer\fR subroutine, at a minimum, and it should return some metadata.
It does not have to return a list of known records (in which case it simply acts as a metadata
descriptor of the repository in general, nothing more... which is fine!... and there will be no
second stage interaction.  In this case, you do not need to provide a \fBMetaRecord\fR subroutine.)
.SH "NAME"
.Vb 1
\&    FAIR::Accessor \- Module for creating Linked Data Platform Accessors for the FAIR Data project
.Ve
.SH "Command-line testing"
.IX Header "Command-line testing"
If you wish to test your Accessor server at the command line, you can run it with the following commandline arguments (in order):
.PP
.Vb 4
\& Method (always GET, at the moment)
\& Domain
\& Request URI (i.e. the path to this script, including the script name)
\& PATH_INFO  (anything that should appear in the PATH_INFO variable of the webserver)
\&
\&  perl  myAccessorScript  GET  example.net  /this/myAccessorScript /1234567
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Denis Wilkinson (markw [at] illuminae [dot] com)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2016 by Mark Denis Wilkinson.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
