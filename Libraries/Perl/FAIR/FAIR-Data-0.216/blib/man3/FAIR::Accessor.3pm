.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "FAIR::Accessor 3"
.TH FAIR::Accessor 3 "2015-07-15" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FAIR::Accessor \- all this does is assign the HTTP call to the correct routine
.SH "VERSION"
.IX Header "VERSION"
version 0.216
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following code is a complete implementation of a 'Hello, World!' \s-1FAIR\s0 Accessor
.PP
.Vb 1
\& #!/usr/bin/perl \-w
\&
\& package HelloWorld_Accessor;  # this should be the same as your filename!
\&
\& use strict;
\& use warnings;
\& use JSON;
\&
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Configuration and Daemon
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\& use base \*(AqFAIR::Accessor\*(Aq;
\&
\& my $config = {
\&    title => \*(AqHello World Data Accessor\*(Aq,
\&    serviceTextualDescription => \*(AqServer for some Helloworld Data\*(Aq,
\&    textualAccessibilityInfo => "The information from this server requries no authentication",  # this could also be a $URI describing the accessibiltiy
\&    mechanizedAccessibilityInfo => "",  # this must be a URI to an RDF document
\&    textualLicenseInfo => "CC\-BY",  # this could also be a URI to the license info
\&    mechanizedLicenseInfo =>  "", # this must be a URI to an RDF document
\&    baseURI => "", # I don\*(Aqt know what this is used for yet, but I have a feeling I will need it!
\&    ETAG_Base => "HelloWorld_Accessor_For_Greetings", # this is a unique identificaiton string for the service (required by the LDP specification)
\&    localNamespaces => {hw => \*(Aqhttp://hello.world.org/some/items/\*(Aq,
\&                        hw2 => \*(Aqhttp://another.hello.world.org/some/predicates/\*(Aq},  # add a few new namespaces to the list of known namespaces....
\&    localMetadataElements => [qw(hw:Greeting hw2:grusse) ],  # things that we use in addition to common metadata elements
\&
\& };
\&
\& my $service = HelloWorld_Accessor\->new(%$config);
\&
\& # start daemon
\& $service\->handle_requests;
\&
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Accessor Implementation
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&
\&
\& =head2 get_all_meta_URIs
\&
\&  Function: REQUIRED SUBROUTINE \- returns the first\-stage LD Platform list of contained URIs and the dataset metadata.
\&  Args    : $starting_at_record : this will be passed\-in to tell you what record to start with (for paginated responses)
\&  $path : the webserver\*(Aqs PATH_INFO environment value (used to modify the behaviour of REST services)
\&  Returns : JSON encoded listref of \*(Aqmeta URIs\*(Aq representing individual records
\&  Note    :  meta URIs are generally URIs that point back to this same server; calling GET on a meta URI will
\&            return an RDF description of the set of DCAT distributions for that record.\e
\&            this can be handled by the
\&
\& =cut
\&
\& sub get_all_meta_URIs {
\&
\&    my ($starting_at_record, $path_info) = @_;
\&    $path_info ||="";
\&    
\&    my %result =  (  # NOTE THAT ALL OF THESE ARE OPTIONAL!  (and there are more fields.... see DCAT...)
\&                    \*(Aqdc:title\*(Aq => "Hello World Accessor Server",
\&                   \*(Aqdcat:description\*(Aq => "the prototype Accessor server for Hello World",
\&                    \*(Aqdcat:identifier\*(Aq => "handle:HelloWorld1234567",
\&                    \*(Aqdcat:keyword\*(Aq => ["greetings", "friendly", "welcome", "Hi"],
\&                    \*(Aqdcat:landingPage\*(Aq => \*(Aqhttp://hello.world.net/homepage.html\*(Aq,
\&                    \*(Aqdcat:language\*(Aq => \*(Aqen\*(Aq,
\&                    \*(Aqdcat:publisher\*(Aq => \*(Aqhttp://hello.world.net\*(Aq,
\&                    \*(Aqdcat:temporal\*(Aq => \*(Aqhttp://reference.data.gov.uk/id/quarter/2006\-Q1\*(Aq,  # look at this!!  It doesn\*(Aqt have to be this complex, but it can be!
\&                    \*(Aqdcat:theme\*(Aq  => \*(Aqhttp://example.org/ConceptSchemes/HelloWorld.rdf\*(Aq,  # this is the URI to a SKOS Concept Scheme
\&                    );
\&    my $BASE_URL = "http://" . $ENV{\*(AqSERVER_NAME\*(Aq} . $ENV{\*(AqREQUEST_URI\*(Aq} . $path_info;
\&
\&   # you may chose to return no record IDs at all, if you only want to serve repository\-level metadata     
\&    my @known_records = ($BASE_URL . "/hello",
\&                         $BASE_URL . "/world",
\&                         # ...  you need to generate this list of record URIs here... somehow
\&                        );
\&    $result{\*(Aqvoid:entities\*(Aq} = scalar(@known_records);  #  THE TOTAL *NUMBER* OF RECORDS THAT CAN BE SERVED
\&    $result{\*(Aqldp:contains\*(Aq} = \e@known_records; # the listref of record ids
\&    
\&    return encode_json(\e%result);
\&
\& }
\&
\&
\& =head2 get_distribution_URIs
\&
\&  Function: REQUIRED IF get_all_meta_URIs list of URIs point back to this script.
\&           returns the second\-stage LD Platform metadata describing the DCAT distributions, formats, and URLs
\&           for a particular record
\&  Args    : $ID : the desired ID number, as determined by the Accessor.pm module
\&           $PATH_INFO : the webserver\*(Aqs PATH_INFO environment value (in case the $ID best\-guess is wrong... then you\*(Aqre on your own!)
\&  Returns : JSON encoded hashref of \*(Aqmeta URIs\*(Aq representing individual DCAT distributions and their formats (format is key)
\&            The format for this response is:
\&            
\&            {"metadata":
\&                {"rdf:type": ["edam:data_0006","sio:SIO_000088"]
\&                },
\&            "distributions":
\&                {"application/rdf+xml":"http://myserver.org/ThisScript/record/479\-467\-29X.rdf",
\&                 "text/html":"http://myserver.org/ThisScript/record/479\-467\-29X.html"
\&                }
\&            }
\&
\& =cut
\&
\&
\& sub get_distribution_URIs {
\&    my ($self, $ID, $PATH_INFO) = @_;
\&
\&    my %response;
\&
\&    my %formats;
\&    my %metadata;
\&    
\&    $formats{\*(Aqtext/html\*(Aq} = \*(Aqhttp://myserver.org/ThisScript/helloworld.html\*(Aq;
\&    $formats{\*(Aqapplication/rdf+xml\*(Aq} = \*(Aqhttp://myserver.org/ThisScript/helloworld.rdf\*(Aq;
\&
\&    # set the ontological type for the record  (optional)
\&    $metadata{\*(Aqrdf:type\*(Aq} = [\*(Aqedam:data_0006\*(Aq, \*(Aqsio:SIO_000088\*(Aq];
\&    
\&    # and whatever other metadata you wish (also optional)
\&    # extractMetaDataFromSpreadsheet(\e%metadata, $ID);    
\&
\&    $response{distributions} = \e%formats;
\&    $response{metadata} = \e%metadata if (keys %metadata);  # only set it if you can provided something
\&
\&    my $response  = encode_json(\e%response);
\&    
\&    return $response;
\&
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1FAIR\s0 Accessors are an implementation of the W3Cs Linked Data Platform.  \s-1FAIR\s0 Accessors follow a two-stage interaction model, where the first stage
retrieves a series of URLs representing meta-records for every record in that repository (or whatever slice of the repository is being served).
This is accomplished by the get_all_meta_URIs subroutine.  These URLs will generally point back at this same Accessor script (e.g. with the
record number appended to the \s-1URL:\s0  http://this.host/thisscript/12345).
.PP
This script then expresses metadata about that record, including the available \s-1DCAT\s0 distributions and their file formats.  This is
accomplished by the get_distribution_URIs subroutine.
.PP
The two subroutine names \- get_all_meta_URIs  and  get_distribution_URIs \- are not flexible, as they are called by the underlying libraries.
.SH "NAME"
.Vb 1
\&    FAIR::Accessor \- Module for creating Linked Data Platform Accessors for the FAIR Data project
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Denis Wilkinson (markw [at] illuminae [dot] com)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2015 by Mark Denis Wilkinson.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
